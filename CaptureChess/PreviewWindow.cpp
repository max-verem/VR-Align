/* -LICENSE-START-
** Copyright (c) 2020 Blackmagic Design
**  
** Permission is hereby granted, free of charge, to any person or organization 
** obtaining a copy of the software and accompanying documentation (the 
** "Software") to use, reproduce, display, distribute, sub-license, execute, 
** and transmit the Software, and to prepare derivative works of the Software, 
** and to permit third-parties to whom the Software is furnished to do so, in 
** accordance with:
** 
** (1) if the Software is obtained from Blackmagic Design, the End User License 
** Agreement for the Software Development Kit (“EULA”) available at 
** https://www.blackmagicdesign.com/EULA/DeckLinkSDK; or
** 
** (2) if the Software is obtained from any third party, such licensing terms 
** as notified by that third party,
** 
** and all subject to the following:
** 
** (3) the copyright notices in the Software and this entire statement, 
** including the above license grant, this restriction and the following 
** disclaimer, must be included in all copies of the Software, in whole or in 
** part, and all derivative works of the Software, unless such copies or 
** derivative works are solely in the form of machine-executable object code 
** generated by a source language processor.
** 
** (4) THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS 
** OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT 
** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE 
** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, 
** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
** DEALINGS IN THE SOFTWARE.
** 
** A copy of the Software is available free of charge at 
** https://www.blackmagicdesign.com/desktopvideo_sdk under the EULA.
** 
** -LICENSE-END-
*/

#include "stdafx.h"
#include <gl/gl.h>
#include "PreviewWindow.h"

PreviewWindow::PreviewWindow() : 
	m_refCount(1), 
	m_deckLinkScreenPreviewHelper(nullptr), 
	m_previewBox(nullptr),
	m_previewBoxDC(nullptr),
	m_openGLctx(nullptr),
	m_previewBoxWidth(0),
	m_previewBoxHeight(0)
{
}

PreviewWindow::~PreviewWindow()
{
	if (m_openGLctx)
	{
		wglDeleteContext(m_openGLctx);
		m_openGLctx = nullptr;
	}

	if (m_previewBoxDC != nullptr)
	{
		m_previewBox->ReleaseDC(m_previewBoxDC);
		m_previewBoxDC = nullptr;
	}
}

bool		PreviewWindow::init(CStatic *previewBox)
{
	if (!previewBox)
		return false;
	
	m_previewBox = previewBox;

	RECT rectWindow;
	m_previewBox->GetWindowRect(&rectWindow);
	m_previewBoxWidth = rectWindow.right - rectWindow.left;
	m_previewBoxHeight = rectWindow.bottom - rectWindow.top;

	// Create the DeckLink screen preview helper
	if (CoCreateInstance(CLSID_CDeckLinkGLScreenPreviewHelper, NULL, CLSCTX_ALL, IID_IDeckLinkGLScreenPreviewHelper, (void**)&m_deckLinkScreenPreviewHelper) != S_OK)
		return false;

	// Initialise OpenGL
	return initOpenGL();
}

bool		PreviewWindow::initOpenGL()
{
	PIXELFORMATDESCRIPTOR	pixelFormatDesc;
	int						pixelFormat;
	bool					result = false;

	//
	// Here, we create an OpenGL context attached to the screen preview box
	// so we can use it later on when we need to draw preview frames.

	// Get the preview box drawing context
	m_previewBoxDC = m_previewBox->GetDC();
	if (m_previewBoxDC == nullptr)
		return false;

	// Ensure the preview box DC uses ARGB pixel format
	ZeroMemory(&pixelFormatDesc, sizeof(pixelFormatDesc));
	pixelFormatDesc.nSize = sizeof(pixelFormatDesc);
	pixelFormatDesc.nVersion = 1;
	pixelFormatDesc.dwFlags = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL;
	pixelFormatDesc.iPixelType = PFD_TYPE_RGBA;
	pixelFormatDesc.cColorBits = 32;
	pixelFormatDesc.cDepthBits = 16;
	pixelFormatDesc.cAlphaBits = 8;
	pixelFormatDesc.iLayerType = PFD_MAIN_PLANE;
	pixelFormat = ChoosePixelFormat(m_previewBoxDC->m_hDC, &pixelFormatDesc);
	if (SetPixelFormat(m_previewBoxDC->m_hDC, pixelFormat, &pixelFormatDesc) == false)
		return false;

	// Create OpenGL rendering context
	m_openGLctx = wglCreateContext(m_previewBoxDC->m_hDC);
	if (m_openGLctx == nullptr)
		return false;

	// Make the new OpenGL context the current rendering context so
	// we can initialise the DeckLink preview helper
	if (wglMakeCurrent(m_previewBoxDC->m_hDC, m_openGLctx) == FALSE)
		return false;

	if (m_deckLinkScreenPreviewHelper->InitializeGL() == S_OK)
		result = true;

	// Reset the OpenGL rendering context
	wglMakeCurrent(nullptr, nullptr);

	return result;
}

HRESULT 	PreviewWindow::QueryInterface(REFIID iid, LPVOID *ppv)
{
	HRESULT result = E_NOINTERFACE;

	if (ppv == nullptr)
		return E_INVALIDARG;

	// Initialise the return result
	*ppv = nullptr;

	// Obtain the IUnknown interface and compare it the provided REFIID
	if (iid == IID_IUnknown)
	{
		*ppv = this;
		AddRef();
		result = S_OK;
	}
	else if (iid == IID_IDeckLinkScreenPreviewCallback)
	{
		*ppv = static_cast<IDeckLinkScreenPreviewCallback*>(this);
		AddRef();
		result = S_OK;

	}

	return result;
}

ULONG		PreviewWindow::AddRef()
{
	return ++m_refCount;
}

ULONG		PreviewWindow::Release()
{
	ULONG newRefValue = --m_refCount;
	if (newRefValue == 0)
		delete this;

	return newRefValue;
}

HRESULT			PreviewWindow::DrawFrame(IDeckLinkVideoFrame* theFrame)
{
	// Make sure we are initialised
	if (!m_deckLinkScreenPreviewHelper || (m_previewBoxDC == nullptr) || (m_openGLctx == nullptr))
		return E_FAIL;

	// First, pass the frame to the DeckLink screen preview helper
	m_deckLinkScreenPreviewHelper->SetFrame(theFrame);

	// Then set the OpenGL rendering context to the one we created before
	wglMakeCurrent(m_previewBoxDC->m_hDC, m_openGLctx);

	// Set the viewport size to preview box, for when dialog size has changed
	RECT rectWindow;
	m_previewBox->GetWindowRect(&rectWindow);
	if ((m_previewBoxWidth != rectWindow.right - rectWindow.left) || (m_previewBoxHeight != rectWindow.bottom - rectWindow.top))
	{
		glViewport(0, 0, rectWindow.right - rectWindow.left, rectWindow.bottom - rectWindow.top);
		m_previewBoxWidth = rectWindow.right - rectWindow.left;
		m_previewBoxHeight = rectWindow.bottom - rectWindow.top;
	}

	// and let the helper take care of the drawing
	m_deckLinkScreenPreviewHelper->PaintGL();

	// Last, reset the OpenGL rendering context
	wglMakeCurrent(nullptr, nullptr);

	return S_OK;
}

