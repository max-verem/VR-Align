/* -LICENSE-START-
** Copyright (c) 2020 Blackmagic Design
**  
** Permission is hereby granted, free of charge, to any person or organization 
** obtaining a copy of the software and accompanying documentation (the 
** "Software") to use, reproduce, display, distribute, sub-license, execute, 
** and transmit the Software, and to prepare derivative works of the Software, 
** and to permit third-parties to whom the Software is furnished to do so, in 
** accordance with:
** 
** (1) if the Software is obtained from Blackmagic Design, the End User License 
** Agreement for the Software Development Kit (“EULA”) available at 
** https://www.blackmagicdesign.com/EULA/DeckLinkSDK; or
** 
** (2) if the Software is obtained from any third party, such licensing terms 
** as notified by that third party,
** 
** and all subject to the following:
** 
** (3) the copyright notices in the Software and this entire statement, 
** including the above license grant, this restriction and the following 
** disclaimer, must be included in all copies of the Software, in whole or in 
** part, and all derivative works of the Software, unless such copies or 
** derivative works are solely in the form of machine-executable object code 
** generated by a source language processor.
** 
** (4) THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS 
** OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT 
** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE 
** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, 
** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
** DEALINGS IN THE SOFTWARE.
** 
** A copy of the Software is available free of charge at 
** https://www.blackmagicdesign.com/desktopvideo_sdk under the EULA.
** 
** -LICENSE-END-
*/

#include "stdafx.h"
#include <algorithm>
#include <vector>
#include "CapturePreview.h"
#include "CapturePreviewDlg.h"
#include "DeckLinkDevice.h"
#include "ProfileCallback.h"
#include "ImageWriter.h"
#include "Bgra32VideoFrame.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

static const std::vector<std::pair<BMDVideoConnection, CString>> kInputConnections =
{
	{ bmdVideoConnectionSDI,		_T("SDI") },
	{ bmdVideoConnectionHDMI,		_T("HDMI") },
	{ bmdVideoConnectionOpticalSDI,	_T("Optical SDI") },
	{ bmdVideoConnectionComponent,	_T("Component") },
	{ bmdVideoConnectionComposite,	_T("Composite") },
	{ bmdVideoConnectionSVideo,		_T("S-Video") },
};

static const std::vector <std::pair<int, const char*>> vrpn_status_ids =
{
    { IDC_VRPN_STATUS_1, "virtual/TRACKER-78@10.1.5.83:3885" },
    { IDC_VRPN_STATUS_2, "virtual/CAMERA-78@10.1.5.83:3885" },
    { IDC_VRPN_STATUS_3, "openvr/GenericTracker/LHR-971C5478@10.1.5.83:3885" },
    { IDC_VRPN_STATUS_4, "openvr/GenericTracker/LHR-731BED54@10.1.5.83:3885" },
#if 0
    { IDC_VRPN_STATUS_2, "virtual/CAMERA-78@10.1.5.83:3885" },
    { IDC_VRPN_STATUS_3, "openvr/GenericTracker/LHR-971C5478@10.1.5.83:3885" },
    { IDC_VRPN_STATUS_4, "openvr/GenericTracker/LHR-731BED54@10.1.5.83:3885" },
#endif
};

CCapturePreviewDlg::CCapturePreviewDlg(CWnd* pParent)
: CDialog(CCapturePreviewDlg::IDD, pParent), m_deckLinkDiscovery(NULL),
m_selectedDevice(NULL)
{
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
    save_flag = 0;
}

void CCapturePreviewDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	DDX_Control(pDX, IDC_INPUT_DEVICE_COMBO, m_deviceListCombo);
	DDX_Control(pDX, IDC_INPUT_CONNECTION_COMBO, m_inputConnectionCombo);
	DDX_Control(pDX, IDC_AUTODETECT_FORMAT_CHECK, m_applyDetectedInputModeCheckbox);
	DDX_Control(pDX, IDC_INPUT_MODE_COMBO, m_modeListCombo);
	DDX_Control(pDX, IDC_START_STOP_BUTTON, m_startStopButton);
	DDX_Control(pDX, IDC_INVALID_INPUT_STATIC, m_invalidInputLabel);

    DDX_Control(pDX, IDC_PREVIEW_BOX, m_previewBox);
}

BEGIN_MESSAGE_MAP(CCapturePreviewDlg, CDialog)
    ON_WM_PAINT()
    ON_WM_QUERYDRAGICON()
    ON_WM_GETMINMAXINFO()
    ON_WM_CLOSE()
    ON_WM_TIMER()

    // my control button
    ON_BN_CLICKED(IDC_BUTTON_SELECT_CAPTURE_DIRECTORY, &CCapturePreviewDlg::OnSelectCaptureDirBnClicked)
    ON_BN_CLICKED(IDC_BUTTON_GRAB_FRAME, &CCapturePreviewDlg::OnGrabFrameBnClicked)

	// UI element messages
	ON_BN_CLICKED(IDC_START_STOP_BUTTON, &CCapturePreviewDlg::OnStartStopBnClicked)
	ON_CBN_SELCHANGE(IDC_INPUT_DEVICE_COMBO, &CCapturePreviewDlg::OnNewDeviceSelected)
	ON_CBN_SELCHANGE(IDC_INPUT_CONNECTION_COMBO, &CCapturePreviewDlg::OnInputConnectionSelected)
	ON_BN_CLICKED(IDC_AUTODETECT_FORMAT_CHECK, &CCapturePreviewDlg::OnAutoDetectCBClicked)

	// Custom messages
	ON_MESSAGE(WM_REFRESH_INPUT_STREAM_DATA_MESSAGE, &CCapturePreviewDlg::OnRefreshInputStreamData)
	ON_MESSAGE(WM_DETECT_VIDEO_MODE_MESSAGE, &CCapturePreviewDlg::OnDetectVideoMode)
	ON_MESSAGE(WM_ADD_DEVICE_MESSAGE, &CCapturePreviewDlg::OnAddDevice)
	ON_MESSAGE(WM_REMOVE_DEVICE_MESSAGE, &CCapturePreviewDlg::OnRemoveDevice)
	ON_MESSAGE(WM_ERROR_RESTARTING_CAPTURE_MESSAGE, &CCapturePreviewDlg::OnErrorRestartingCapture)
	ON_MESSAGE(WM_UPDATE_PROFILE_MESSAGE, &CCapturePreviewDlg::OnProfileUpdate)
END_MESSAGE_MAP()

void CCapturePreviewDlg::OnStartStopBnClicked()
{
	if (m_selectedDevice == NULL)
		return;

	if (m_selectedDevice->isCapturing())
		StopCapture();
	else
		StartCapture();
}

void CCapturePreviewDlg::OnNewDeviceSelected()
{
	int			selectedDeviceIndex;

	m_selectedDevice = nullptr;

	selectedDeviceIndex = m_deviceListCombo.GetCurSel();
	if (selectedDeviceIndex < 0)
		return;

	if (m_selectedDevice)
	{
		// Unsubscribe to input device callbacks
		m_selectedDevice->setErrorListener(nullptr);
		m_selectedDevice->onVideoFormatChange(nullptr);
		m_selectedDevice->onVideoFrameArrival(nullptr);

		m_selectedDevice.Release();
	}

	// Find input device based on IDeckLink* object
	auto iter = m_inputDevices.find((IDeckLink*)m_deviceListCombo.GetItemDataPtr(selectedDeviceIndex));
	if (iter == m_inputDevices.end())
		return;

	m_selectedDevice = iter->second;

	if (m_selectedDevice)
	{
		// Subscribe to input device callbacks
		m_selectedDevice->setErrorListener(std::bind(&CCapturePreviewDlg::HandleDeviceError, this, std::placeholders::_1));
		m_selectedDevice->onVideoFormatChange([this](BMDDisplayMode displayMode) { PostMessage(WM_DETECT_VIDEO_MODE_MESSAGE, 0, (LPARAM)displayMode); });
		m_selectedDevice->onVideoFrameArrival(std::bind(&CCapturePreviewDlg::VideoFrameArrived, this, std::placeholders::_1));

		// Update the input video connections combo
		RefreshInputConnectionList();

		EnableInterface(true);
	}
}


void CCapturePreviewDlg::OnInputConnectionSelected()
{
	int selectedConnectionIndex;

	selectedConnectionIndex = m_inputConnectionCombo.GetCurSel();
	if (selectedConnectionIndex < 0)
		return;

	m_selectedInputConnection = (BMDVideoConnection)m_inputConnectionCombo.GetItemData(selectedConnectionIndex);

	// Configure input connection for selected device
	if (m_selectedDevice->getDeckLinkConfiguration()->SetInt(bmdDeckLinkConfigVideoInputConnection, (int64_t)m_selectedInputConnection) != S_OK)
		return;

	// Updated video mode combo for selected input connection
	RefreshVideoModeList();
}

void CCapturePreviewDlg::OnAutoDetectCBClicked()
{
	m_modeListCombo.EnableWindow(m_selectedDevice && (m_applyDetectedInputModeCheckbox.GetCheck() == BST_UNCHECKED) ? TRUE : FALSE);
}

void CCapturePreviewDlg::OnClose()
{
	// Stop the capture
	StopCapture();

	// Disable profile callback
	if (m_selectedDevice) 
	{
		m_selectedDevice.Release();
	}

    ImageWriter::UnInitialize();

	// Release all DeckLinkDevice instances
	for (auto& device : m_inputDevices)
	{
		CComQIPtr<IDeckLinkProfileManager> profileManager(device.second->getDeckLinkInstance());
		if (profileManager)
			profileManager->SetCallback(nullptr);

		device.second.Release();
	}

	// Release profile callback
	m_profileCallback.Release();

	// Release preview window
	m_previewWindow.Release();

	// Release DeckLink discovery instance
    if(m_deckLinkDiscovery != nullptr)
    	m_deckLinkDiscovery->disable();
	m_deckLinkDiscovery.Release();

    for (CVrpnStatusDlg* vrpn : m_vrpn_status)
    {
        vrpn->DestroyWindow();
        delete vrpn;
    };

	CDialog::OnClose();
}


void CCapturePreviewDlg::ShowErrorMessage(TCHAR* msg, TCHAR* title)
{
	MessageBox(msg, title);
}

void CCapturePreviewDlg::RefreshInputDeviceList()
{
	int index;
	BOOL hasActiveInputDevices;

	m_deviceListCombo.ResetContent();

	for (auto& device : m_inputDevices)
	{
		CComQIPtr<IDeckLinkProfileAttributes> deckLinkAttributes(device.second->getDeckLinkInstance());

		if (deckLinkAttributes)
		{
			int64_t intAttribute;
			if ((deckLinkAttributes->GetInt(BMDDeckLinkDuplex, &intAttribute) == S_OK) &&
				(((BMDDuplexMode)intAttribute) != bmdDuplexInactive))
			{
				// Input device is active, add to combobox
				index = m_deviceListCombo.AddString(device.second->getDeviceName());
				m_deviceListCombo.SetItemDataPtr(index, (void*)device.first);

				// Retain selected device even if combo box position has changed
				if (device.second == m_selectedDevice)
					m_deviceListCombo.SetCurSel(index);
			}
		}
	}

	hasActiveInputDevices = m_deviceListCombo.GetCount() > 0;

	// If there is at least 1 active device, enable start/stop button
	m_startStopButton.EnableWindow(hasActiveInputDevices);

	if (hasActiveInputDevices)
	{
		// If device has been removed or becomes inactive due to profile change, then select first device in combobox
		index = m_deviceListCombo.GetCurSel();
		if (index == CB_ERR)
		{
			m_deviceListCombo.SetCurSel(0);
			OnNewDeviceSelected();
		}
	}
	else
		m_selectedDevice = nullptr;

	// If a device is selected and not capturing then enable interface
	EnableInterface(m_selectedDevice && !m_selectedDevice->isCapturing());
}

void CCapturePreviewDlg::RefreshInputConnectionList()
{
	CComQIPtr<IDeckLinkProfileAttributes>	deckLinkAttributes(m_selectedDevice->getDeckLinkInstance());
	LONGLONG								availableInputConnections;
	LONGLONG								currentInputConnection;
	int										index;

	m_inputConnectionCombo.ResetContent();

	if (!deckLinkAttributes)
		return;

	// Get the available input video connections for the device
	if (deckLinkAttributes->GetInt(BMDDeckLinkVideoInputConnections, &availableInputConnections) != S_OK)
		availableInputConnections = bmdVideoConnectionUnspecified;

	// Get the current selected input connection
	if (m_selectedDevice->getDeckLinkConfiguration()->GetInt(bmdDeckLinkConfigVideoInputConnection, &currentInputConnection) != S_OK)
	{
		currentInputConnection = bmdVideoConnectionUnspecified;
	}

	for (auto connection : kInputConnections)
	{
		if ((connection.first & (BMDVideoConnection)availableInputConnections) != 0)
		{
			// Input video connection is supported by device, add to combo
			index = m_inputConnectionCombo.AddString(connection.second);
			m_inputConnectionCombo.SetItemData(index, connection.first);

			// If input connection is the active connection set combo to this item
			if (connection.first == (BMDVideoConnection)currentInputConnection)
			{
				m_inputConnectionCombo.SetCurSel(index);
				OnInputConnectionSelected();
			}
		}
	}

	// If no input connection has been selected, select first index
	index = m_inputConnectionCombo.GetCurSel();
	if ((index == CB_ERR) && (m_inputConnectionCombo.GetCount() > 0))
	{
		m_inputConnectionCombo.SetCurSel(0);
		OnInputConnectionSelected();
	}
}

void CCapturePreviewDlg::RefreshVideoModeList()
{
	m_modeListCombo.ResetContent();

	m_selectedDevice->queryDisplayModes([this](CComPtr<IDeckLinkDisplayMode>& deckLinkDisplayMode)
	{
        CComBSTR	modeName;
		int			newIndex;
		BOOL		supported;

		// Check that display mode is supported with the active profile
		if ((m_selectedDevice->getDeckLinkInput()->DoesSupportVideoMode(m_selectedInputConnection, deckLinkDisplayMode->GetDisplayMode(), bmdFormatUnspecified,
			bmdNoVideoInputConversion, bmdSupportedVideoModeDefault, nullptr, &supported) != S_OK) ||
			!supported)
		{
			return;
		}

		if (deckLinkDisplayMode->GetName(&modeName) != S_OK)
			return;

		// Add this item to the video format popup menu
		newIndex = m_modeListCombo.AddString(CString(modeName));

		// Save the BMDDisplayMode in the menu item's tag
		m_modeListCombo.SetItemData(newIndex, deckLinkDisplayMode->GetDisplayMode());
	});

	if (m_modeListCombo.GetCount() > 0)
	{
		// Select first item in list
		m_modeListCombo.SetCurSel(0);
	}

	m_startStopButton.EnableWindow(m_modeListCombo.GetCount() > 0);
}

void CCapturePreviewDlg::StartCapture()
{
	bool	applyDetectedInputMode = (m_applyDetectedInputModeCheckbox.GetCheck() == BST_CHECKED);
	int		selectedVideoFormatIndex = m_modeListCombo.GetCurSel();

	if (selectedVideoFormatIndex < 0)
		return;

	if (m_selectedDevice)
	{
		if (m_selectedDevice->startCapture((BMDDisplayMode)m_modeListCombo.GetItemData(selectedVideoFormatIndex), m_previewWindow, applyDetectedInputMode))
		{
			// Update UI
			m_startStopButton.SetWindowText(_T("Stop capture"));
			EnableInterface(false);
		}
		else
		{
			m_selectedDevice->stopCapture();
		}
	}
}

void CCapturePreviewDlg::StopCapture()
{
	if (m_selectedDevice)
		m_selectedDevice->stopCapture();

	// Update UI
	m_startStopButton.SetWindowText(_T("Start capture"));
	EnableInterface(true);
	m_invalidInputLabel.ShowWindow(SW_HIDE);
}

void CCapturePreviewDlg::EnableInterface(bool enabled)
{
	m_deviceListCombo.EnableWindow((enabled) ? TRUE : FALSE);
	m_inputConnectionCombo.EnableWindow((enabled) ? TRUE : FALSE);

	if (enabled)
	{
		if (m_selectedDevice && m_selectedDevice->doesSupportFormatDetection())
		{
			m_applyDetectedInputModeCheckbox.EnableWindow(TRUE);
			m_applyDetectedInputModeCheckbox.SetCheck(BST_CHECKED);
			m_modeListCombo.EnableWindow(FALSE);
		}
		else
		{
			m_applyDetectedInputModeCheckbox.EnableWindow(FALSE);
			m_applyDetectedInputModeCheckbox.SetCheck(BST_UNCHECKED);
			m_modeListCombo.EnableWindow(TRUE);
		}
	}
	else
	{
		m_applyDetectedInputModeCheckbox.EnableWindow(FALSE);
		m_modeListCombo.EnableWindow(FALSE);
	}
}

static HRESULT GetDeckLinkVideoConversion(IDeckLinkVideoConversion **deckLinkVideoConversion)
{
    HRESULT result = S_OK;

    result = CoCreateInstance(CLSID_CDeckLinkVideoConversion, NULL, CLSCTX_ALL, IID_IDeckLinkVideoConversion, (void**)deckLinkVideoConversion);
    if (FAILED(result))
    {
        fprintf(stderr, "A DeckLink video conversion interface could not be created.\n");
    }

    return result;
}

void CCapturePreviewDlg::VideoFrameArrived(CComPtr<IDeckLinkVideoInputFrame>& videoFrame)
{
	{
		std::lock_guard<std::mutex> lock(m_mutex);

        if (save_flag)
        {
            FILE* f;
            CString folderPath;
            char path[1024];
            GetDlgItem(IDC_BUTTON_SELECT_CAPTURE_DIRECTORY)->GetWindowText(folderPath);

            snprintf(path, sizeof(path), "%s/%lld.vrpn", (LPCTSTR)folderPath, save_flag);
            f = fopen(path, "wt");
            if (f)
            {
                for (CVrpnStatusDlg* vrpn : m_vrpn_status)
                {
                    q_type quat;
                    q_vec_type pos, yawPitchRoll;

                    fprintf(f, "%s\t", vrpn->vrpn_addr);

                    vrpn->get_pos_rot(pos, quat);

                    q_to_euler(yawPitchRoll, quat);

                    fprintf(f, "%f,%f,%f", pos[0], pos[1], pos[2]);

                    fprintf(f, "\t");

                    fprintf(f, "%f,%f,%f",
                        yawPitchRoll[0] * 180.0 / 3.1415926,
                        yawPitchRoll[1] * 180.0 / 3.1415926,
                        yawPitchRoll[2] * 180.0 / 3.1415926);

                    fprintf(f, "\t");

                    fprintf(f, "%f,%f,%f,%f", quat[0], quat[1], quat[2], quat[3]);

                    fprintf(f, "\n");
                }
                fclose(f);

                snprintf(path, sizeof(path), "%s/%lld.png", (LPCTSTR)folderPath, save_flag);

                {
                    std::string pngFilename(path);
                    IDeckLinkVideoFrame* bgra32Frame = NULL;

                    if (videoFrame->GetPixelFormat() == bmdFormat8BitBGRA)
                    {
                        // Frame is already 8-bit BGRA - no conversion required
                        bgra32Frame = videoFrame;
                        bgra32Frame->AddRef();
                    }
                    else
                    {
                        IDeckLinkVideoConversion* deckLinkFrameConverter = NULL;
                        GetDeckLinkVideoConversion(&deckLinkFrameConverter);
                        bgra32Frame = new Bgra32VideoFrame(videoFrame->GetWidth(), videoFrame->GetHeight(), videoFrame->GetFlags());
                        deckLinkFrameConverter->ConvertFrame(videoFrame, bgra32Frame);
                    }

                    ImageWriter::WriteBgra32VideoFrameToPNG(bgra32Frame, pngFilename);
                    bgra32Frame->Release();
                };

            };

            save_flag = 0;
            GetDlgItem(IDC_BUTTON_GRAB_FRAME)->EnableWindow(1);
        };

	}

	// Update the UI
	PostMessage(WM_REFRESH_INPUT_STREAM_DATA_MESSAGE, (videoFrame->GetFlags() & bmdFrameHasNoInputSource), 0);
}

void CCapturePreviewDlg::HandleDeviceError(DeviceError error)
{
	switch (error)
	{
		case DeviceError::EnableVideoInputFailed:
			ShowErrorMessage(_T("This application was unable to select the chosen video mode. Perhaps, the selected device is currently in-use."), _T("Error starting the capture"));
			break;

		case DeviceError::StartStreamsFailed:
			ShowErrorMessage(_T("This application was unable to start the capture. Perhaps, the selected device is currently in-use."), _T("Error starting the capture"));
			break;

		case DeviceError::ReenableVideoInputFailed:
			PostMessage(WM_ERROR_RESTARTING_CAPTURE_MESSAGE, 0, 0);
			break;
	}
}

BOOL	CCapturePreviewDlg::OnInitDialog()
{
	CDialog::OnInitDialog();
	SetIcon(m_hIcon, FALSE);

	// Set initial dialog size as minimum size
	CRect rectWindow;
	GetWindowRect(rectWindow);
	m_minDialogSize = rectWindow.Size();

	// Empty popup menus
	m_deviceListCombo.ResetContent();
	m_modeListCombo.ResetContent();

	// Disable the interface
	m_startStopButton.EnableWindow(FALSE);
	EnableInterface(false);

    ImageWriter::Initialize();

    for (auto status_id : vrpn_status_ids)
    {
        CVrpnStatusDlg* vrpn_status = new CVrpnStatusDlg(this);
        {
            CRect rc;
            GetDlgItem(status_id.first)->GetWindowRect(rc);
            ScreenToClient(&rc);
            vrpn_status->MoveWindow(rc);
            vrpn_status->ShowWindow(SW_SHOW);
            vrpn_status->setVRPN(status_id.second);
        };

        m_vrpn_status.push_back(vrpn_status);
    };

    SetTimer(WM_MAIN_LOOP_VRPN_MESSAGE, 10, NULL);
    SetTimer(WM_UPDATE_VRPN_MESSAGE, 100, NULL);

	// Create and initialise preview, profile callback and DeckLink device discovery objects 
	m_previewWindow.Attach(new PreviewWindow());
	if (m_previewWindow->init(&m_previewBox) == false)
	{
		ShowErrorMessage(_T("This application was unable to initialise the preview window"), _T("Error"));
		goto bail;
	}

	m_profileCallback.Attach(new ProfileCallback());
	m_profileCallback->onHaltStreams(std::bind(&CCapturePreviewDlg::HaltStreams, this, std::placeholders::_1));
	m_profileCallback->onProfileActivated([this](CComPtr<IDeckLinkProfile>& /* unused */) {
		// Update UI with new profile
		PostMessage(WM_UPDATE_PROFILE_MESSAGE, 0, 0);
	});

	try
	{
		m_deckLinkDiscovery.Attach(new DeckLinkDeviceDiscovery());

		if (!m_deckLinkDiscovery->enable())
			throw std::runtime_error("This application requires the DeckLink drivers installed.\nPlease install the Blackmagic DeckLink drivers to use the features of this application.");
	}
	catch (const std::exception& e)
	{
		CString errorString(e.what());
		MessageBox(errorString, _T("Error"));
		return FALSE;
	}

	m_deckLinkDiscovery->onDeviceArrival([this](CComPtr<IDeckLink> &dl) {
		// Update UI (add new device to menu) from main thread
		PostMessage(WM_ADD_DEVICE_MESSAGE, (WPARAM)dl.Detach(), 0);
	});

	m_deckLinkDiscovery->onDeviceRemoval([this](CComPtr<IDeckLink> &dl) {
		// Update UI (remove device from menu) from main thread
		PostMessage(WM_REMOVE_DEVICE_MESSAGE, (WPARAM)dl.Detach(), 0);
		dl.Release();
	});

bail:
	return TRUE;
}

void CCapturePreviewDlg::AddDevice(CComPtr<IDeckLink>& deckLink)
{	
	CComPtr<DeckLinkDevice>		newDevice;

	try
	{
		newDevice.Attach(new DeckLinkDevice(deckLink));
	}
	catch (...)
	{
		// Device does not have IDeckLinkInput interface, eg it is a DeckLink Mini Monitor
		return;
	}

	// Initialise new DeckLinkDevice object
	if (!newDevice->init())
		return;

	// Register profile callback with newly added device's profile manager
	CComQIPtr<IDeckLinkProfileManager> profileManager(newDevice->getDeckLinkInstance());
	if (profileManager)
		profileManager->SetCallback(m_profileCallback);

	// Store input device to map to maintain reference
	m_inputDevices[deckLink] = std::move(newDevice);
	RefreshInputDeviceList();
}

void CCapturePreviewDlg::RemoveDevice(CComPtr<IDeckLink>& deckLink)
{
	// Remove input device from list 
	auto iter = m_inputDevices.find(deckLink);
	if (iter != m_inputDevices.end())
	{
		CComPtr<DeckLinkDevice> deviceToRemove = iter->second;
		CComQIPtr<IDeckLinkProfileManager> profileManager(deviceToRemove->getDeckLinkInstance());

		if (deviceToRemove->isCapturing())
			deviceToRemove->stopCapture();

		// Release profile callback from device to remove
		if (profileManager)
			profileManager->SetCallback(nullptr);

		// Release DeckLinkDevice instance
		deviceToRemove.Release();

		m_inputDevices.erase(iter);

		// Update input device combo box
		RefreshInputDeviceList();
	}
}

void    CCapturePreviewDlg::HaltStreams(CComPtr<IDeckLinkProfile>& newProfile)
{
	CComPtr<IDeckLink> deckLink;

	// Profile is changing, stop capture if running
	if ((newProfile->GetDevice(&deckLink) == S_OK) &&
		(m_selectedDevice->getDeckLinkInstance() == deckLink) &&
		(m_selectedDevice->isCapturing()))
	{
		StopCapture();
	}
}

LRESULT  CCapturePreviewDlg::OnRefreshInputStreamData(WPARAM wParam, LPARAM lParam)
{
	{
		// Update the UI under protection of mutex lock
		std::lock_guard<std::mutex> lock(m_mutex);
    }

	m_invalidInputLabel.ShowWindow((wParam) ? SW_SHOW : SW_HIDE);

	return 0;
}

LRESULT CCapturePreviewDlg::OnDetectVideoMode(WPARAM wParam, LPARAM lParam)
{
	BMDDisplayMode	detectedVideoMode;
	int				modeIndex;
	
	// A new video mode was auto-detected, update the video mode combo box
	detectedVideoMode = (BMDDisplayMode)lParam;
	
	for (modeIndex = 0; modeIndex < m_modeListCombo.GetCount(); modeIndex++)
	{
		if (m_modeListCombo.GetItemData(modeIndex) == detectedVideoMode)
		{
			m_modeListCombo.SetCurSel(modeIndex);
			break;
		}
	}

	return 0;
}


LRESULT CCapturePreviewDlg::OnAddDevice(WPARAM wParam, LPARAM lParam)
{
	// A new device has been connected
	CComPtr<IDeckLink> deckLink;
	deckLink.Attach((IDeckLink*)wParam);
	AddDevice(deckLink);
	return 0;
}

LRESULT	CCapturePreviewDlg::OnRemoveDevice(WPARAM wParam, LPARAM lParam)
{
	// An existing device has been disconnected
	CComPtr<IDeckLink> deckLink;
	deckLink.Attach((IDeckLink*)wParam);
	RemoveDevice(deckLink);
	return 0;
}

LRESULT	CCapturePreviewDlg::OnErrorRestartingCapture(WPARAM wParam, LPARAM lParam)
{
	// A change in the input video mode was detected, but the capture could not be restarted.
	StopCapture();
	ShowErrorMessage(_T("This application was unable to apply the detected input video mode."), _T("Error restarting the capture."));
	return 0;
}

LRESULT CCapturePreviewDlg::OnProfileUpdate(WPARAM wParam, LPARAM lParam)
{
	// Check whether device is active/inactive and update input device combobox, 
	// following the same steps as if the device was added/removed. 
	RefreshInputDeviceList();
	return 0;
}

void CCapturePreviewDlg::OnPaint()
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, reinterpret_cast<WPARAM>(dc.GetSafeHdc()), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this function to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CCapturePreviewDlg::OnQueryDragIcon()
{
	return static_cast<HCURSOR>(m_hIcon);
}

// Required to ensure minimum size of dialog
void CCapturePreviewDlg::OnGetMinMaxInfo(MINMAXINFO* minMaxInfo)
{
	CDialog::OnGetMinMaxInfo(minMaxInfo);

	minMaxInfo->ptMinTrackSize.x = std::max(minMaxInfo->ptMinTrackSize.x, m_minDialogSize.cx);
	minMaxInfo->ptMinTrackSize.y = std::max(minMaxInfo->ptMinTrackSize.y, m_minDialogSize.cy);
}

void getAncillaryDataFromFrame(CComPtr<IDeckLinkVideoInputFrame>& videoFrame, BMDTimecodeFormat timecodeFormat, CString& timecodeString, CString& userBitsString)
{
	CComPtr<IDeckLinkTimecode>		timecode;
	CComBSTR						timecodeBstr;
	BMDTimecodeUserBits				userBits;

	timecodeString = _T("");
	userBitsString = _T("");

	if (videoFrame && (videoFrame->GetTimecode(timecodeFormat, &timecode) == S_OK))
	{
		if (timecode->GetString(&timecodeBstr) == S_OK)
			timecodeString = timecodeBstr;

		if (timecode->GetTimecodeUserBits(&userBits) == S_OK)
			userBitsString.Format(_T("0x%08X"), userBits);
	}
}

INT CALLBACK BrowseCallbackProc(HWND hwnd, UINT uMsg, LPARAM lp, LPARAM pData)
{
    if (uMsg == BFFM_INITIALIZED) SendMessage(hwnd, BFFM_SETSELECTION, TRUE, pData);
    return 0;
}

void CCapturePreviewDlg::OnSelectCaptureDirBnClicked()
{
    CString folderPath;

    GetDlgItem(IDC_BUTTON_SELECT_CAPTURE_DIRECTORY)->GetWindowText(folderPath);

#if 0
    CFolderPickerDialog folderPickerDialog(folderPath, 0, this, 0);
    
//    folderPickerDialog.m_ofn.lpstrTitle = _T("Put your title here");
//    folderPickerDialog.m_ofn.lpstrInitialDir = _T("C:\\");
    
    if (folderPickerDialog.DoModal() == IDOK)
    {
        folderPath = folderPickerDialog.GetFolderPath();
        GetDlgItem(IDC_BUTTON_SELECT_CAPTURE_DIRECTORY)->SetWindowText(folderPath);
    }
#else
    BROWSEINFO bi = { 0 };
    memset(&bi, 0, sizeof(bi));
    bi.hwndOwner = this->m_hWnd;
    bi.lpfn = BrowseCallbackProc;
    bi.lParam = (LPARAM)folderPath.GetString();    // https://www.arclab.com/en/kb/cppmfc/select-folder-shbrowseforfolder.html
    bi.lpszTitle = _T("Select Folder");
    bi.ulFlags = BIF_DONTGOBELOWDOMAIN | BIF_RETURNONLYFSDIRS | /* BIF_NEWDIALOGSTYLE | */ BIF_EDITBOX;
    LPITEMIDLIST pl = SHBrowseForFolder(&bi); // https://www.programmersought.com/article/10735369463/
    if (!pl)
        return;

    TCHAR path[MAX_PATH];
    SHGetPathFromIDList(pl, path);
    folderPath = path;

    IMalloc * imalloc = 0;
    if (SUCCEEDED(SHGetMalloc(&imalloc))) {
        imalloc->Free(pl);
        imalloc->Release();
    }
#endif

    GetDlgItem(IDC_BUTTON_SELECT_CAPTURE_DIRECTORY)->SetWindowText(folderPath);
}

void  CCapturePreviewDlg::OnGrabFrameBnClicked()
{
    GetDlgItem(IDC_BUTTON_GRAB_FRAME)->EnableWindow(0);
    save_flag = time(NULL);
}

void CCapturePreviewDlg::OnTimer(UINT_PTR nIdEvent)
{
    if (nIdEvent == WM_UPDATE_VRPN_MESSAGE)
    {
        for (CVrpnStatusDlg* vrpn : m_vrpn_status)
            ::PostMessage(vrpn->m_hWnd, WM_UPDATE_VRPN_MESSAGE, 0, 0);
    }
    else if (nIdEvent == WM_MAIN_LOOP_VRPN_MESSAGE)
    {
        for (CVrpnStatusDlg* vrpn : m_vrpn_status)
            ::PostMessage(vrpn->m_hWnd, WM_MAIN_LOOP_VRPN_MESSAGE, 0, 0);
    };

}

